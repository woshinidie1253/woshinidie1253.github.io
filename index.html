<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>跳一跳 - HTML5 Canvas</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
                   "Segoe UI", Roboto, sans-serif;
      background: radial-gradient(circle at 20% 0%, #fdfbfb 0, #ebedee 30%, #1f2335 100%);
      color: #fff;
    }
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: pointer;
    }
    .hint-overlay {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 30px;
      text-align: center;
      font-size: 14px;
      color: rgba(255,255,255,0.85);
      text-shadow: 0 1px 3px rgba(0,0,0,0.6);
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hint-overlay">
  按住屏幕 / 鼠标蓄力，松开起跳 ｜ 空格键也可以操作
</div>
<script>
(function () {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let W = 0, H = 0;
  let dpr = window.devicePixelRatio || 1;

  // 物理参数
  const GRAVITY = 1600;          // 重力加速度 px/s²
  const MIN_POWER = 650;         // 最小初速度
  const MAX_POWER = 1500;        // 最大初速度
  const MAX_CHARGE_TIME = 900;   // 最大蓄力时间 ms

  // 游戏状态
  let platforms = [];
  let particles = [];
  let floatingTexts = [];
  let player = null;
  let gameState = 'ready';       // 'ready' | 'charging' | 'jumping' | 'gameover'
  let holdStart = 0;
  let holdTime = 0;
  let score = 0;
  let bestScore = 0;
  let combo = 0;
  let cameraX = 0;

  // 震动效果
  let shakeTime = 0;
  let shakeMag = 0;

  // 时间控制
  let lastTime = 0;

  // 颜色/平台配置
  const PLATFORM_COLORS = [
    '#FF9A9E', '#FAD0C4', '#FBC2EB', '#A6C1EE',
    '#A1C4FD', '#C2E9FB', '#FEE140', '#FA709A'
  ];

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    dpr = window.devicePixelRatio || 1;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  // 初始化最佳成绩
  (function initBestScore () {
    try {
      const val = localStorage.getItem('jump_best_score');
      if (val) bestScore = parseInt(val, 10) || 0;
    } catch (e) {
      bestScore = 0;
    }
  })();

  function createPlatform(x, y, width) {
    const color = PLATFORM_COLORS[(Math.random() * PLATFORM_COLORS.length) | 0];
    return {
      x,
      y,
      width,
      height: 26,
      color
    };
  }

  function spawnNextPlatform(prev) {
    const minDx = 160;
    const maxDx = 340;
    const minDy = -120;
    const maxDy = 120;

    let x = prev.x + minDx + Math.random() * (maxDx - minDx);
    let y = prev.y + minDy + Math.random() * (maxDy - minDy);

    const topLimit = H * 0.3;
    const bottomLimit = H * 0.8;
    if (y < topLimit) y = topLimit;
    if (y > bottomLimit) y = bottomLimit;

    const width = 80 + Math.random() * 80;
    return createPlatform(x, y, width);
  }

  function createInitialPlatforms() {
    platforms.length = 0;
    const baseY = H * 0.7;
    const first = createPlatform(W * 0.3, baseY, 150);
    platforms.push(first);
    let prev = first;
    for (let i = 0; i < 6; i++) {
      prev = spawnNextPlatform(prev);
      platforms.push(prev);
    }
  }

  function resetGame() {
    score = 0;
    combo = 0;
    cameraX = 0;
    particles.length = 0;
    floatingTexts.length = 0;
    shakeTime = 0;
    shakeMag = 0;
    createInitialPlatforms();
    const first = platforms[0];
    player = {
      x: first.x,
      y: first.y - 44,
      radius: 24,
      vx: 0,
      vy: 0,
      chargeScale: 1,
      currentPlatform: first
    };
    gameState = 'ready';
  }

  function ensurePlatforms() {
    // 向前补充平台
    let last = platforms[platforms.length - 1];
    if (!last) return;
    while (last.x - cameraX < W * 2) {
      const next = spawnNextPlatform(last);
      platforms.push(next);
      last = next;
    }
    // 清理离开视野的平台
    while (platforms.length && platforms[0].x + platforms[0].width < cameraX - W * 0.5) {
      platforms.shift();
    }
  }

  function spawnLandingEffect(x, y, color) {
    const count = 24;
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 150 + Math.random() * 260;
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed * 0.5,
        life: 0,
        maxLife: 0.4 + Math.random() * 0.3,
        color
      });
    }
  }

  function addFloatingText(text, x, y, color) {
    floatingTexts.push({
      text,
      x,
      y,
      color,
      life: 0,
      maxLife: 0.8
    });
  }

  function startCharge() {
    if (gameState === 'ready') {
      gameState = 'charging';
      holdStart = performance.now();
      holdTime = 0;
    } else if (gameState === 'gameover') {
      resetGame();
    }
  }

  function releaseCharge() {
    if (gameState !== 'charging') return;
    holdTime = performance.now() - holdStart;
    const t = Math.min(1, holdTime / MAX_CHARGE_TIME);
    const power = MIN_POWER + (MAX_POWER - MIN_POWER) * t;
    const angle = -Math.PI / 3;  // 约 60 度
    player.vx = Math.cos(angle) * power;
    player.vy = Math.sin(angle) * power;
    gameState = 'jumping';
  }

  function triggerGameOver() {
    if (gameState === 'gameover') return;
    gameState = 'gameover';
  }

  function update(dt) {
    if (!player) return;

    // 限制 dt，防止后台切回造成大跳
    dt = Math.min(dt, 0.032);

    // 蓄力时角色压缩动画
    if (gameState === 'charging') {
      const now = performance.now();
      holdTime = now - holdStart;
      const t = Math.min(1, holdTime / MAX_CHARGE_TIME);
      player.chargeScale = 1 - 0.25 * t;
    } else {
      // 回弹
      player.chargeScale += (1 - player.chargeScale) * Math.min(1, dt * 14);
    }

    // 跳跃物理
    if (gameState === 'jumping') {
      const prevBottom = player.y + player.radius;
      player.vy += GRAVITY * dt;
      player.x += player.vx * dt;
      player.y += player.vy * dt;
      const currBottom = player.y + player.radius;

      // 检测平台碰撞（只在下降时）
      let landedPlatform = null;
      if (player.vy > 0) {
        for (let i = 0; i < platforms.length; i++) {
          const p = platforms[i];
          const left = p.x - p.width / 2;
          const right = p.x + p.width / 2;
          if (player.x > left && player.x < right) {
            if (prevBottom <= p.y && currBottom >= p.y) {
              landedPlatform = p;
              break;
            }
          }
        }
      }

      if (landedPlatform) {
        // 落地
        player.y = landedPlatform.y - player.radius;
        player.vx = 0;
        player.vy = 0;
        player.currentPlatform = landedPlatform;
        gameState = 'ready';

        // 得分与连击
        score += 1;
        const centerDist = Math.abs(player.x - landedPlatform.x);
        let bonus = 0;
        if (centerDist < 10) {
          combo += 1;
          bonus = 2 + Math.min(3, combo - 1); // 连击越高额外分数略高
          addFloatingText(`完美! +${1 + bonus}`, player.x, player.y - 60, 'rgba(255,255,255,0.95)');
        } else if (centerDist < landedPlatform.width * 0.25) {
          addFloatingText('+1', player.x, player.y - 50, 'rgba(255,255,255,0.85)');
          combo = 0;
        } else {
          combo = 0;
        }
        score += bonus;

        if (score > bestScore) {
          bestScore = score;
          try {
            localStorage.setItem('jump_best_score', String(bestScore));
          } catch (e) {}
        }

        // 震动 & 粒子特效
        shakeTime = 0.14;
        shakeMag = 10;
        spawnLandingEffect(player.x, player.y + player.radius * 0.6, landedPlatform.color);

        ensurePlatforms();
      } else {
        // 掉下去了
        if (player.y - player.radius > H + 200) {
          triggerGameOver();
        }
      }
    }

    // 相机跟随
    const targetCameraX = Math.max(0, player.x - W * 0.35);
    cameraX += (targetCameraX - cameraX) * Math.min(1, dt * 3);

    // 震动时间衰减
    if (shakeTime > 0) {
      shakeTime -= dt;
      if (shakeTime < 0) shakeTime = 0;
    }

    // 粒子更新
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.life += dt;
      if (p.life > p.maxLife) {
        particles.splice(i, 1);
        continue;
      }
      p.vy += GRAVITY * 0.3 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
    }

    // 飘字更新
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const f = floatingTexts[i];
      f.life += dt;
      f.y -= 30 * dt;
      if (f.life > f.maxLife) {
        floatingTexts.splice(i, 1);
      }
    }
  }

  // 绘制辅助函数
  function drawRoundedRect(x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x - w / 2 + rr, y);
    ctx.lineTo(x + w / 2 - rr, y);
    ctx.quadraticCurveTo(x + w / 2, y, x + w / 2, y + rr);
    ctx.lineTo(x + w / 2, y + h - rr);
    ctx.quadraticCurveTo(x + w / 2, y + h, x + w / 2 - rr, y + h);
    ctx.lineTo(x - w / 2 + rr, y + h);
    ctx.quadraticCurveTo(x - w / 2, y + h, x - w / 2, y + h - rr);
    ctx.lineTo(x - w / 2, y + rr);
    ctx.quadraticCurveTo(x - w / 2, y, x - w / 2 + rr, y);
    ctx.closePath();
  }

  function drawBackground() {
    // 远景山
    const baseY = H * 0.75;
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#151a2f';
    ctx.beginPath();
    ctx.moveTo(-100, baseY);
    ctx.lineTo(W + 100, baseY);
    ctx.lineTo(W * 0.7, baseY - 140);
    ctx.lineTo(W * 0.4, baseY - 90);
    ctx.lineTo(W * 0.2, baseY - 170);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // 星光点缀
    ctx.save();
    ctx.globalAlpha = 0.45;
    for (let i = 0; i < 40; i++) {
      const x = (i * 97) % (W + 50);
      const y = (i * 53) % (H * 0.6);
      const r = (i % 3) * 0.4 + 0.6;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fill();
    }
    ctx.restore();
  }

  function render() {
    if (!player) return;
    ctx.clearRect(0, 0, W, H);

    drawBackground();

    // 震动偏移
    const offsetX = shakeTime > 0 ? (Math.random() * 2 - 1) * shakeMag : 0;
    const offsetY = shakeTime > 0 ? (Math.random() * 2 - 1) * shakeMag : 0;

    ctx.save();
    ctx.translate(offsetX, offsetY);

    // 地面轻微渐变
    const groundY = H * 0.82;
    const grd = ctx.createLinearGradient(0, groundY - 40, 0, H + 40);
    grd.addColorStop(0, 'rgba(0,0,0,0.1)');
    grd.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = grd;
    ctx.fillRect(0, groundY, W, H - groundY + 40);

    // 绘制平台
    platforms.forEach(p => {
      const screenX = p.x - cameraX;
      const screenY = p.y;
      const w = p.width;
      const h = p.height;

      // 阴影
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = 'black';
      ctx.filter = 'blur(6px)';
      ctx.beginPath();
      ctx.ellipse(screenX, screenY + h + 10, w * 0.45, h * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // 平台主体
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 4;
      drawRoundedRect(screenX, screenY, w, h, 10);
      const topGrad = ctx.createLinearGradient(0, screenY, 0, screenY + h);
      topGrad.addColorStop(0, p.color);
      topGrad.addColorStop(1, '#2b2f4b');
      ctx.fillStyle = topGrad;
      ctx.fill();
      ctx.restore();

      // 顶部高光
      ctx.save();
      ctx.globalAlpha = 0.18;
      drawRoundedRect(screenX, screenY, w * 0.86, h * 0.35, 8);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.restore();
    });

    // 角色阴影
    const playerScreenX = player.x - cameraX;
    const playerScreenY = player.y;
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.filter = 'blur(4px)';
    ctx.beginPath();
    ctx.ellipse(playerScreenX, playerScreenY + player.radius + 12,
                player.radius * 0.9, player.radius * 0.55, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'black';
    ctx.fill();
    ctx.restore();

    // 角色本体
    ctx.save();
    ctx.translate(playerScreenX, playerScreenY);
    ctx.scale(1, player.chargeScale);

    // 身体
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.35)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 4;
    const bodyH = player.radius * 1.4;
    drawRoundedRect(0, -bodyH, player.radius * 1.6, bodyH, 12);
    const bodyGrad = ctx.createLinearGradient(0, -bodyH, 0, 0);
    bodyGrad.addColorStop(0, '#ffecd2');
    bodyGrad.addColorStop(1, '#fcb69f');
    ctx.fillStyle = bodyGrad;
    ctx.fill();
    ctx.restore();

    // 头部
    ctx.beginPath();
    ctx.arc(0, -bodyH - player.radius * 0.6, player.radius * 0.85, 0, Math.PI * 2);
    const headGrad = ctx.createLinearGradient(0, -bodyH - player.radius * 1.4,
                                              0, -bodyH + player.radius * 0.2);
    headGrad.addColorStop(0, '#fff');
    headGrad.addColorStop(1, '#ffe0c2');
    ctx.fillStyle = headGrad;
    ctx.fill();

    // 脸
    ctx.save();
    ctx.translate(0, -bodyH - player.radius * 0.7);
    // 眼睛
    ctx.beginPath();
    ctx.arc(-player.radius * 0.3, 0, 2.3, 0, Math.PI * 2);
    ctx.arc(player.radius * 0.3, 0, 2.3, 0, Math.PI * 2);
    ctx.fillStyle = '#30313a';
    ctx.fill();
    // 嘴
    ctx.beginPath();
    ctx.arc(0, player.radius * 0.2, player.radius * 0.25, 0, Math.PI);
    ctx.strokeStyle = '#30313a';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.restore();

    // 蓄力圈
    if (gameState === 'charging') {
      const t = Math.min(1, holdTime / MAX_CHARGE_TIME);
      ctx.beginPath();
      ctx.arc(0, -bodyH - player.radius * 0.6, player.radius * 1.1,
              -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * t);
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    ctx.restore(); // 还原角色 transform

    // 粒子效果
    particles.forEach(p => {
      const lifeRatio = p.life / p.maxLife;
      const alpha = 1 - lifeRatio;
      const screenX = p.x - cameraX;
      const screenY = p.y;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(screenX, screenY, 3 + (1 - lifeRatio) * 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });

    // 飘字
    floatingTexts.forEach(f => {
      const lifeRatio = f.life / f.maxLife;
      const alpha = 1 - lifeRatio;
      const screenX = f.x - cameraX;
      const screenY = f.y;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = f.color;
      ctx.fillText(f.text, screenX, screenY);
      ctx.restore();
    });

    ctx.restore(); // 震动 translate

    // HUD：得分 / 最佳 / 连击
    ctx.save();
    ctx.textBaseline = 'top';

    // 当前得分
    ctx.font = 'bold 36px system-ui';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.shadowColor = 'rgba(0,0,0,0.45)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 3;
    ctx.fillText(String(score), W / 2, 18);

    // 最佳成绩
    ctx.font = '14px system-ui';
    ctx.textAlign = 'right';
    ctx.shadowBlur = 6;
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText(`最佳: ${bestScore}`, W - 18, 22);

    // 连击
    if (combo >= 2 && gameState !== 'gameover') {
      ctx.font = '16px system-ui';
      ctx.textAlign = 'left';
      ctx.fillStyle = 'rgba(255,230,180,0.95)';
      ctx.fillText(`连击 x${combo}`, 18, 24);
    }

    // 提示 / Game Over
    if (gameState === 'ready' && score === 0) {
      ctx.font = '16px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillText('按住蓄力，松开起跳', W / 2, H * 0.6);
    }

    if (gameState === 'gameover') {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, W, H);
      ctx.font = 'bold 30px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = 'rgba(0,0,0,0.6)';
      ctx.shadowBlur = 10;
      ctx.fillText('游戏结束', W / 2, H / 2 - 20);
      ctx.font = '18px system-ui';
      ctx.fillText('点击 / 按空格重新开始', W / 2, H / 2 + 24);
      ctx.restore();
    }

    ctx.restore();
  }

  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    update(dt);
    render();
    window.requestAnimationFrame(loop);
  }

  // 输入控制
  let pointerDown = false;

  function onPointerDown(e) {
    pointerDown = true;
    startCharge();
  }

  function onPointerUp(e) {
    if (!pointerDown) return;
    pointerDown = false;
    releaseCharge();
  }

  canvas.addEventListener('mousedown', onPointerDown);
  window.addEventListener('mouseup', onPointerUp);

  canvas.addEventListener('touchstart', function (e) {
    e.preventDefault();
    onPointerDown(e);
  }, { passive: false });

  window.addEventListener('touchend', function (e) {
    e.preventDefault();
    onPointerUp(e);
  }, { passive: false });

  // 键盘（空格）
  let keyCharging = false;
  window.addEventListener('keydown', function (e) {
    if (e.code === 'Space' || e.key === ' ') {
      if (!keyCharging) {
        keyCharging = true;
        startCharge();
      }
      e.preventDefault();
    }
  });

  window.addEventListener('keyup', function (e) {
    if (e.code === 'Space' || e.key === ' ') {
      if (keyCharging) {
        keyCharging = false;
        releaseCharge();
      }
      e.preventDefault();
    }
  });

  window.addEventListener('resize', function () {
    resize();
    // 重新布局但不重置分数
    // 这里简化处理，直接重开一局，避免尺寸变化带来奇怪的物理状态
    resetGame();
  });

  // 启动游戏
  resize();
  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
